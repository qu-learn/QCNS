/**
 * QCNS - Quantum Circuit and Network Simulator
 * OpenQASM v3 Transpiler Module
 *
 * This module converts QuantumCircuit objects to valid OpenQASM v3 code.
 * Based on OpenQASM v3.1 specification and standard library.
 */

export class QasmTranspiler {
    constructor() {
        // Gate mapping from QCNS gate names to OpenQASM v3 syntax
        this.gateMapping = {
            // Single-qubit gates
            'id': 'id',
            'x': 'x',
            'y': 'y',
            'z': 'z',
            'h': 'h',
            's': 's',
            't': 't',
            'sdg': 'sdg',
            'tdg': 'tdg',
            'sx': 'sx',

            // Parameterized single-qubit gates
            'rx': 'rx',
            'ry': 'ry',
            'rz': 'rz',
            'p': 'p',       // phase gate
            'u1': 'u1',
            'u2': 'u2',
            'u3': 'u3',

            // Two-qubit gates
            'cx': 'cx',
            'cnot': 'cx',   // alias for cx
            'cy': 'cy',
            'cz': 'cz',
            'ch': 'ch',
            'cp': 'cp',
            'crx': 'crx',
            'cry': 'cry',
            'crz': 'crz',
            'swap': 'swap',
            'iswap': 'iswap',

            // Three-qubit gates
            'ccx': 'ccx',
            'toffoli': 'ccx',  // alias for ccx
            'cswap': 'cswap',
            'fredkin': 'cswap' // alias for cswap
        };

        // Parameters for parameterized gates
        this.parameterizedGates = new Set([
            'rx', 'ry', 'rz', 'p', 'u1', 'u2', 'u3',
            'cp', 'crx', 'cry', 'crz'
        ]);

        this.version = '3.1';
    }

    /**
     * Convert a QuantumCircuit to OpenQASM v3 string
     * @param {QuantumCircuit} circuit - The quantum circuit to transpile
     * @param {Object} options - Transpilation options
     * @returns {string} OpenQASM v3 code
     */
    transpile(circuit, options = {}) {
        const {
            includeVersion = true,
            includeStdGates = true,
            includeComments = true,
            optimize = false,
            addMetadata = true
        } = options;

        let qasm = [];

        // Header with enhanced comments
        if (includeComments) {
            qasm.push('// Generated by QCNS (Quantum Circuit and Network Simulator)');
            qasm.push('// OpenQASM v3.1 output');

            if (addMetadata) {
                qasm.push(`// Circuit: ${circuit.name || 'Unnamed'}`);
                qasm.push(`// Qubits: ${circuit.numQubits}, Classical bits: ${circuit.numClbits}`);
                qasm.push(`// Generated: ${new Date().toISOString()}`);
            }

            qasm.push('');
        }

        // Version declaration
        if (includeVersion) {
            qasm.push('OPENQASM 3;');
        }

        // Include standard gates
        if (includeStdGates) {
            qasm.push('include "stdgates.inc";');
        }

        qasm.push('');

        // Qubit declarations
        if (circuit.qreg.name === 'qreg' && circuit.numQubits > 1) {
            qasm.push(`qubit[${circuit.numQubits}] q;`);
        } else if (circuit.numQubits === 1) {
            qasm.push('qubit q;');
        } else {
            qasm.push(`qubit[${circuit.numQubits}] ${circuit.qreg.name};`);
        }

        // Classical bit declarations
        if (circuit.numClbits > 0) {
            if (circuit.creg.name === 'creg' && circuit.numClbits > 1) {
                qasm.push(`bit[${circuit.numClbits}] c;`);
            } else if (circuit.numClbits === 1) {
                qasm.push('bit c;');
            } else {
                qasm.push(`bit[${circuit.numClbits}] ${circuit.creg.name};`);
            }
        }

        qasm.push('');

        // Circuit gates
        const gateLines = this.transpileGates(circuit);
        qasm.push(...gateLines);

        return qasm.join('\n');
    }

    /**
     * Transpile all gates in the circuit
     * @param {QuantumCircuit} circuit - The quantum circuit
     * @returns {Array} Array of QASM gate lines
     */
    transpileGates(circuit) {
        const quantumLines = [];
        const measurementLines = [];
        const numCols = circuit.numCols();

        // First pass: collect all quantum gates (non-measurement gates)
        for (let col = 0; col < numCols; col++) {
            const columnGates = this.getGatesAtColumn(circuit, col);

            for (const gate of columnGates) {
                if (gate) {
                    if (gate.name === 'measure') {
                        // Store measurements for later
                        const qasmLine = this.transpileGate(circuit, gate);
                        if (qasmLine) {
                            measurementLines.push(qasmLine);
                        }
                    } else {
                        // Process quantum gates immediately
                        const qasmLine = this.transpileGate(circuit, gate);
                        if (qasmLine) {
                            quantumLines.push(qasmLine);
                        }
                    }
                }
            }
        }

        // Combine quantum gates first, then measurements at the end
        const lines = [...quantumLines];

        if (measurementLines.length > 0) {
            if (quantumLines.length > 0) {
                lines.push(''); // Empty line before measurements for readability
            }
            lines.push(...measurementLines);
        }

        return lines;
    }

    /**
     * Get all gates at a specific column
     * @param {QuantumCircuit} circuit - The quantum circuit
     * @param {number} column - Column index
     * @returns {Array} Array of gates at the column
     */
    getGatesAtColumn(circuit, column) {
        const gates = [];
        const processedGates = new Set();

        for (let wire = 0; wire < circuit.numQubits; wire++) {
            const gate = circuit.gates[wire][column];
            if (gate && !processedGates.has(gate.id)) {
                gates.push(gate);
                processedGates.add(gate.id);
            }
        }

        return gates;
    }

    /**
     * Transpile a single gate to OpenQASM v3
     * @param {QuantumCircuit} circuit - The quantum circuit
     * @param {Object} gate - The gate object
     * @returns {string} OpenQASM v3 gate line
     */
    transpileGate(circuit, gate) {
        const gateName = gate.name;

        if (gateName === 'measure') {
            return this.transpileMeasurement(circuit, gate);
        }

        if (gateName === 'barrier') {
            return this.transpileBarrier(circuit, gate);
        }

        const qasmGateName = this.gateMapping[gateName];
        if (!qasmGateName) {
            throw new Error(`Unknown gate: ${gateName}`);
        }

        // Find which wires this gate operates on
        const wires = this.findGateWires(circuit, gate);
        const qubitRefs = this.formatQubitReferences(circuit, wires);

        // Handle parameterized gates
        if (this.parameterizedGates.has(qasmGateName)) {
            const params = this.extractGateParameters(gate);
            if (params.length === 0) {
                throw new Error(`Parameterized gate ${gateName} missing parameters`);
            }
            const paramStr = params.map(p => this.formatParameter(p)).join(', ');
            return `${qasmGateName}(${paramStr}) ${qubitRefs.join(', ')};`;
        }

        // Non-parameterized gates
        return `${qasmGateName} ${qubitRefs.join(', ')};`;
    }

    /**
     * Transpile a barrier directive
     * @param {QuantumCircuit} circuit - The quantum circuit
     * @param {Object} gate - The barrier gate
     * @returns {string} OpenQASM v3 barrier line
     */
    transpileBarrier(circuit, gate) {
        const wires = this.findGateWires(circuit, gate);
        const qubitRefs = this.formatQubitReferences(circuit, wires);

        // If barrier spans all qubits, use simplified syntax
        if (wires.length === circuit.numQubits) {
            return 'barrier;';
        }

        return `barrier ${qubitRefs.join(', ')};`;
    }

    /**
     * Transpile a measurement operation
     * @param {QuantumCircuit} circuit - The quantum circuit
     * @param {Object} gate - The measurement gate
     * @returns {string} OpenQASM v3 measurement line
     */
    transpileMeasurement(circuit, gate) {
        const wires = this.findGateWires(circuit, gate);
        if (wires.length !== 1) {
            throw new Error('Measurement gate must operate on exactly one qubit');
        }

        const qubitRef = this.formatQubitReference(circuit, wires[0]);
        const options = gate.options || {};

        if (options.creg) {
            const cregName = options.creg.name === 'creg' ? 'c' : options.creg.name;
            const cbitIndex = options.creg.bit;

            if (circuit.numClbits === 1 && cbitIndex === 0) {
                return `${cregName} = measure ${qubitRef};`;
            } else {
                return `${cregName}[${cbitIndex}] = measure ${qubitRef};`;
            }
        }

        // Default measurement without classical register specification
        return `measure ${qubitRef};`;
    }

    /**
     * Find which wires a gate operates on
     * @param {QuantumCircuit} circuit - The quantum circuit
     * @param {Object} gate - The gate object
     * @returns {Array} Array of wire indices
     */
    findGateWires(circuit, gate) {
        const wires = [];
        const numCols = circuit.numCols();

        for (let wire = 0; wire < circuit.numQubits; wire++) {
            for (let col = 0; col < numCols; col++) {
                if (circuit.gates[wire][col] === gate) {
                    wires.push(wire);
                    break;
                }
            }
        }

        return wires.sort((a, b) => a - b); // Sort for consistency
    }

    /**
     * Format qubit references for OpenQASM v3
     * @param {QuantumCircuit} circuit - The quantum circuit
     * @param {Array} wires - Array of wire indices
     * @returns {Array} Array of formatted qubit references
     */
    formatQubitReferences(circuit, wires) {
        return wires.map(wire => this.formatQubitReference(circuit, wire));
    }

    /**
     * Format a single qubit reference
     * @param {QuantumCircuit} circuit - The quantum circuit
     * @param {number} wire - Wire index
     * @returns {string} Formatted qubit reference
     */
    formatQubitReference(circuit, wire) {
        const qregName = circuit.qreg.name === 'qreg' ? 'q' : circuit.qreg.name;

        if (circuit.numQubits === 1) {
            return qregName;
        } else {
            return `${qregName}[${wire}]`;
        }
    }

    /**
     * Extract parameters from a gate
     * @param {Object} gate - The gate object
     * @returns {Array} Array of parameter values
     */
    extractGateParameters(gate) {
        const options = gate.options || {};
        const params = options.params || {};

        // Common parameter names mapping
        const paramOrder = {
            'rx': ['theta'],
            'ry': ['theta'],
            'rz': ['theta'],
            'p': ['lambda'],
            'u1': ['lambda'],
            'u2': ['phi', 'lambda'],
            'u3': ['theta', 'phi', 'lambda'],
            'cp': ['lambda'],
            'crx': ['theta'],
            'cry': ['theta'],
            'crz': ['theta']
        };

        const expectedParams = paramOrder[gate.name] || [];
        const result = [];

        for (const paramName of expectedParams) {
            if (paramName in params) {
                result.push(params[paramName]);
            } else {
                throw new Error(`Missing parameter ${paramName} for gate ${gate.name}`);
            }
        }

        return result;
    }

    /**
     * Format a parameter value for OpenQASM v3
     * @param {*} param - Parameter value
     * @returns {string} Formatted parameter
     */
    formatParameter(param) {
        if (typeof param === 'number') {
            // Handle special values with better precision
            const pi = Math.PI;
            const tolerance = 1e-10;

            // Check for exact multiples of pi
            if (Math.abs(param - pi) < tolerance) return 'π';
            if (Math.abs(param + pi) < tolerance) return '-π';
            if (Math.abs(param - 2 * pi) < tolerance) return '2*π';
            if (Math.abs(param + 2 * pi) < tolerance) return '-2*π';

            // Check for fractions of pi
            if (Math.abs(param - pi / 2) < tolerance) return 'π/2';
            if (Math.abs(param + pi / 2) < tolerance) return '-π/2';
            if (Math.abs(param - pi / 4) < tolerance) return 'π/4';
            if (Math.abs(param + pi / 4) < tolerance) return '-π/4';
            if (Math.abs(param - 3 * pi / 4) < tolerance) return '3*π/4';
            if (Math.abs(param + 3 * pi / 4) < tolerance) return '-3*π/4';
            if (Math.abs(param - pi / 8) < tolerance) return 'π/8';
            if (Math.abs(param + pi / 8) < tolerance) return '-π/8';
            if (Math.abs(param - 3 * pi / 8) < tolerance) return '3*π/8';
            if (Math.abs(param + 3 * pi / 8) < tolerance) return '-3*π/8';
            if (Math.abs(param - 5 * pi / 8) < tolerance) return '5*π/8';
            if (Math.abs(param + 5 * pi / 8) < tolerance) return '-5*π/8';
            if (Math.abs(param - 7 * pi / 8) < tolerance) return '7*π/8';
            if (Math.abs(param + 7 * pi / 8) < tolerance) return '-7*π/8';

            // Check for rational multiples of pi
            for (let n = 1; n <= 16; n++) {
                for (let d = 2; d <= 16; d++) {
                    const fraction = (n / d) * pi;
                    if (Math.abs(param - fraction) < tolerance) {
                        return n === 1 ? `π/${d}` : `${n}*π/${d}`;
                    }
                    if (Math.abs(param + fraction) < tolerance) {
                        return n === 1 ? `-π/${d}` : `-${n}*π/${d}`;
                    }
                }
            }

            // Return formatted number for other values
            if (Number.isInteger(param)) return param.toString();

            // Use scientific notation for very small or large numbers
            if (Math.abs(param) < 1e-6 || Math.abs(param) > 1e6) {
                return param.toExponential(6);
            }

            // Round to 6 decimal places for readability
            return param.toPrecision(6);
        }

        if (typeof param === 'string') {
            // Validate and clean up string parameters
            const cleanParam = param.trim();

            // Handle symbolic expressions
            if (cleanParam.includes('π') || cleanParam.includes('pi')) {
                return cleanParam.replace(/pi/g, 'π');
            }

            // Handle mathematical expressions
            if (/^[\d\.\+\-\*\/\(\)\sπ]+$/.test(cleanParam)) {
                return cleanParam;
            }

            throw new Error(`Invalid parameter expression: ${param}`);
        }

        throw new Error(`Unsupported parameter type: ${typeof param}`);
    }

    /**
     * Validate that the circuit can be transpiled
     * @param {QuantumCircuit} circuit - The quantum circuit
     * @throws {Error} If circuit cannot be transpiled
     */
    validate(circuit) {
        if (!circuit || typeof circuit !== 'object') {
            throw new Error('Circuit must be a valid QuantumCircuit object');
        }

        if (!circuit.numQubits || circuit.numQubits < 1) {
            throw new Error('Circuit must have at least 1 qubit');
        }

        if (circuit.numQubits > 1000) {
            throw new Error('Circuit has too many qubits (max 1000)');
        }

        // Check for unsupported gates
        const numCols = circuit.numCols();
        for (let col = 0; col < numCols; col++) {
            for (let wire = 0; wire < circuit.numQubits; wire++) {
                const gate = circuit.gates[wire][col];
                if (gate && gate.name !== 'measure' && gate.name !== 'barrier' && !this.gateMapping[gate.name]) {
                    throw new Error(`Unsupported gate: ${gate.name}`);
                }
            }
        }
    }

    /**
     * Get supported gate names
     * @returns {Array} Array of supported gate names
     */
    getSupportedGates() {
        return Object.keys(this.gateMapping);
    }

    /**
     * Check if a gate is supported
     * @param {string} gateName - Gate name to check
     * @returns {boolean} True if supported
     */
    isGateSupported(gateName) {
        return gateName in this.gateMapping || gateName === 'measure' || gateName === 'barrier';
    }
}